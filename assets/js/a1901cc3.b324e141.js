"use strict";(self.webpackChunksvgo_dev=self.webpackChunksvgo_dev||[]).push([[3442],{1709:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var n=r(5893),i=r(1151);const s={title:"prefixIds",svgo:{pluginId:"prefixIds",parameters:{delim:{description:"<p>Content to insert between the prefix and original value.</p>",default:"__"},prefix:{description:"<p>Either a string or a function that resolves to a string.</p>"},prefixIds:{description:"<p>If to prefix <code>id</code> attributes.</p>",default:!0},prefixClassNames:{description:"<p>If to prefix classes in the <code>class</code> attribute.</p>",default:!0}}}},o=void 0,a={id:"plugins/prefixIds",title:"prefixIds",description:"Prefix element IDs and class names with the filename or another arbitrary string. This is useful for reducing the likeliness of ID conflicts when multiple vectors are inlined into the same document.",source:"@site/.svgo/docs/03-plugins/prefixIds.mdx",sourceDirName:"03-plugins",slug:"/plugins/prefixIds",permalink:"/docs/plugins/prefixIds",draft:!1,unlisted:!1,editUrl:"https://github.com/svg/svgo/tree/main/docs/03-plugins/prefixIds.mdx",tags:[],version:"current",frontMatter:{title:"prefixIds",svgo:{pluginId:"prefixIds",parameters:{delim:{description:"<p>Content to insert between the prefix and original value.</p>",default:"__"},prefix:{description:"<p>Either a string or a function that resolves to a string.</p>"},prefixIds:{description:"<p>If to prefix <code>id</code> attributes.</p>",default:!0},prefixClassNames:{description:"<p>If to prefix classes in the <code>class</code> attribute.</p>",default:!0}}}},sidebar:"docsSidebar",previous:{title:"moveGroupAttrsToElems",permalink:"/docs/plugins/moveGroupAttrsToElems"},next:{title:"removeAttributesBySelector",permalink:"/docs/plugins/removeAttributesBySelector"}},d={},l=[{value:"Prefer Reproducible IDs",id:"prefer-reproducible-ids",level:2}];function p(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Prefix element IDs and class names with the filename or another arbitrary string. This is useful for reducing the likeliness of ID conflicts when multiple vectors are inlined into the same document."}),"\n",(0,n.jsx)(t.h2,{id:"prefer-reproducible-ids",children:"Prefer Reproducible IDs"}),"\n",(0,n.jsx)(t.p,{children:"It's acceptable to generate IDs that have no relation to the node or file they're for, such as through a counter, random number generator, or UUID. Consider the following SVGO config:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",metastring:'title="svgo.config.js"',children:"let prefixCounter = 0;\n\nmodule.exports = {\n  plugins: [\n    {\n      name: 'prefixIds',\n      params: {\n        delim: '',\n        prefix: () => prefixCounter++,\n      },\n    },\n  ],\n};\n"})}),"\n",(0,n.jsx)(t.p,{children:"However, a solution like this can not gurantee a reproducible prefix. Unpredictable IDs can pose an issue for tooling, namely React, and anything that depends on it like Next.js and Docusaurus."}),"\n",(0,n.jsx)(t.p,{children:"With unpredictable IDs, if you're prerendering or use SSR (Server-Side Rendering), the client-side and server-side HTML may mismatch, leading to errors on client-side and regenerating the tree."}),"\n",(0,n.jsx)(t.p,{children:"For this reason, it's preferred to use reproducible prefixes where possible. Consider using the filename or node as a seed to produce a shorter string, rather than generating something from scratch."})]})}function c(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>a,a:()=>o});var n=r(7294);const i={},s=n.createContext(i);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);